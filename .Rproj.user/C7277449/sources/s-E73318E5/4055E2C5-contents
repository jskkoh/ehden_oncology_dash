library("shiny")
library("tidyverse")
library("ggrepel")
library("DT")
library("knitr")
library("markdown")
source("functions.R")

shinyServer(function(input, output,session) {

  
# Create tables from UI inputs --------------------------------------------

  # Population outcomes
  resCEA <- reactive({
      data.frame(comparator=1,qalys=input$incQALYs_c1,cost=input$incCost_c1,
                 pop=as.numeric(input$intPop_c1))
  })
  
  # Live HOC distribution
  distHOC <- reactive({
    distHOC_scenarios %>% filter(scenario==input$choiceHOC) %>% select(-scenario)
  })
  
  # User defined HOC dist total
  output$hoc_user_warning <- renderText({ 
   if(input$choiceHOC=="flat") {
     "Health opportunity costs are distributed equally across deprivation groups"
   } else {
     "Health opportunity costs fall disproportionately on the more deprived groups"
   }
  })
  
  output$disthoc_plot <- renderPlot({
      plot_hoc_dist(distHOC())
  })
  
  # User defined prevalence distribution
  distPrev_user <- reactive({
    table = data.frame(imd=1:5,prop_prev=c(input$prevQ1,input$prevQ2,
                                          input$prevQ3,input$prevQ4,input$prevQ5))
  })
  
  sumPrev_user <- reactive({ input$prevQ1+input$prevQ2+input$prevQ3+input$prevQ4+input$prevQ5
  })
  output$prev_user_warning <- renderText({ 
    paste("WARNING: Distribution currently sums to ",
          sumPrev_user(),". Please amend the totals so that they sum to 1 before proceeding.",
          sep="") 
  })
  
  # Auto-generated prevalence distribution (from ICD / RF selection)
  distPrev_auto <- reactive({ 
    table_prevalence_raw(input$intervention_type,input$intICD,input$intRF,input$age_range,resCEA())
  })
  
  # Live prevalence distribution (selected based on UI input)
  distPrev <- reactive({
    if((is.null(input$intICD) & is.null(input$intRF)) | input$choiceRecPop==1 ) {
      distPrev_user()
    } else {
      distPrev_auto()    
      }
  })
  
  # Utilisation full uptake
  distUtilFull <- reactive({
    table = data.frame(imd=1:5,util_rate=c(1,1,1,1,1))
  })
  
   distUtil1 <- reactive({
    table = data.frame(imd=1:5,util_rate=c(input$util1Q1,input$util1Q2,
                                           input$util1Q3,input$util1Q4,input$util1Q5))
  })
  
  distUtil2 <- reactive({
    table = data.frame(imd=1:5,util_rate=c(input$util2Q1,input$util2Q2,
                                           input$util2Q3,input$util2Q4,input$util2Q5))
  })

  # QALY effect multipliers
  distQALYeffect <- reactive({
    table = data.frame(imd=1:5,qaly_mod=c(input$qaly1Q1,input$qaly1Q2,
                                           input$qaly1Q3,input$qaly1Q4,input$qaly1Q5))
  })
  
  
# Create UI objects -------------------------------------------------------

  # ICD selection box
  output$icd_codes=renderUI(
    selectizeInput("intICD", 
                "ICD code(s)",
                unique(distICD$icd), 
                multiple=TRUE)                      
  )
  
  # Risk factor selection list
  output$risk_factors=renderUI(
    checkboxGroupInput("intRF","Risk factor(s)",unique(distRF$risk_factor))
  )
  
  # Create a reactive risk factor / disease population estimate for the comparator input fields
  popRF <- reactive({
      risk_factor_pop(input$intRF)
  })
  popICD <- reactive({
      icd_pop(input$intICD,input$age_range)
  })
  observeEvent({
    input$intRF
    }, {
    updateNumericInput(session,"intPop_c1",value=popRF())
  })
  observeEvent({
    input$intICD
    input$age_range
  }, {
    updateNumericInput(session,"intPop_c1",value=popICD())
  })


  # Eligible population statement (Dist inputs tab)
  popElig <- reactive({
    
    format(sum(resCEA()$pop), big.mark=",")
  })
  output$elig_pop_text <- renderText({ 
    paste0("The socioeconomic distribution of the eligible population (n=",popElig(),") has been automatically generated from 
    disease / risk factor prevalence data. A custom distribution can be defined below (a value between 0 and 1 indicating 
    the share of the eligible population in each IMD quintile group).")
  })
  
  # ICER statement 
  baseICER <- reactive({
    icer_calc(resCEA())
  })
  output$icer_text <- renderText({ 
      if(baseICER()=="dominant") {
        paste0("These incremental inputs define the intervention as dominating the comparator")
      } else if(baseICER()=="dominated") {
        paste0("These incremental inputs define the intervention as being dominated by the comparator")
      } else {
        paste0("These incremental inputs define the incremental cost-effectiveness ratio (ICER) to be Â£",baseICER(),
               " per QALY")
      }
  })
  
  # Raw ICER
  baseICER_raw <- reactive({
    icer_calc_raw(resCEA())
  })
  
  # Weighted incremental QALYs statement
  wtQALY <- reactive({
    wt_qaly_calc(resCEA(),distQALYeffect(),recipients_table_raw1())
  })
  output$wt_qaly_text <- renderText({ 
    paste0("This set of multipliers yield an average incremental QALY gain of ",wtQALY()," per person")
    
  })
    
  
  # Recipient pop statements
  popRec1 <- reactive({
    format(sum(recipients_table_raw1()$recipients_util), big.mark=",")
  })
  popRec2 <- reactive({
    format(sum(recipients_table_raw2()$recipients_util), big.mark=",")
  })
  
  output$rec_pop_text1 <- renderText({ 
    if(popRec1()!=popElig()) {
      paste0("This utilisation scenario yields a recipient population of ",popRec1())
    } else {
      paste0("This utilisation scenario yields a recipient population equal to the 
             eligible population (",popRec1(),").")
    }
  })
  output$rec_pop_text2 <- renderText({ 
    if(popRec2()!=popElig()) {
      paste0("This utilisation scenario yields a recipient population of ",popRec2())
    } else {
      paste0("This utilisation scenario yields a recipient population equal to the 
             eligible population (",popRec2(),").")
    }
  })
  
  
  # Input summary table ------------------------------------------------------
  
  distIncQALY <- reactive({
    qaly_dist(resCEA(),distQALYeffect())
  })
  
  output$input_summary <- renderDataTable({
    withProgress(message = 'Loading data table',{
      table = table_inputSummary(distPrev(),distUtil1(),distIncQALY(),distHOC())
      datatable(table,
                style = 'bootstrap',
                rownames = FALSE,
                options = list(paging=FALSE,searching=FALSE,info=FALSE))
    })
  })
  
  # Non-output version for Markdown report
  input_summary_table <- reactive({
    table_inputSummary(distPrev(),distUtil1(),distIncQALY(),distHOC())
  })
  
  
  
# Recipient distribution tables and plots ---------------------------------
  

  # Raw tables for each uptake scenario
  recipients_table_raw1 = reactive({
    table_recipients_raw(distPrev(),distUtil1(),resCEA())
  })
  recipients_table_raw2 = reactive({
    table_recipients_raw(distPrev(),distUtil2(),resCEA())
  })
  
  # Output tables for each scenario
  output$recipients_table1 = renderDataTable({
    withProgress(message = 'Loading data table',{
      table = table_recipients(recipients_table_raw1())
      datatable(table,
                style = 'bootstrap',
                rownames = FALSE,
                options = list(paging=FALSE,searching=FALSE,info=FALSE))
    })
  })
  
  output$recipients_table2 = renderDataTable({
    withProgress(message = 'Loading data table',{
      table = table_recipients(recipients_table_raw2())
      datatable(table,
                style = 'bootstrap',
                rownames = FALSE,
                options = list(paging=FALSE,searching=FALSE,info=FALSE))
    })
  })

  # Output plot w/ both scenarios (if selected)
  output$recipients_plot = renderPlot({
    withProgress(message = 'Loading plot',{
      plot_recipients(recipients_table_raw1(),recipients_table_raw2(),
                      input$choiceUptake2,input$intName1)
    })
  })


# Net benefit tab ---------------------------------------------------------

  # Net benefits table
  netbenefit_table_raw1 = reactive({
    table_netbenefit_raw(recipients_table_raw1(),distHOC(),input$ratioHOC,
                         distQALYeffect(),resCEA())
  })
  netbenefit_table_raw2 = reactive({
    table_netbenefit_raw(recipients_table_raw2(),distHOC(),input$ratioHOC,
                         distQALYeffect(),resCEA())
  })
  
  weightedicer_raw = reactive({ 
    table_weightedicer_raw(netbenefit_table_raw1(),netbenefit_table_raw2(),
                           input$ratioHOC,imp_AtWeights_full)
  })
  
  output$netbenefit_table =renderDataTable({
    withProgress(message = 'Loading data table',{
      if(input$netBen_uptake_choice=="base") {
        table = table_netbenefit(netbenefit_table_raw1())
      } else {
        table = table_netbenefit(netbenefit_table_raw2())      
        }
      datatable(table,
                style = 'bootstrap',
                rownames = FALSE,
                options = list(paging=FALSE,searching=FALSE,info=FALSE))
    })
  })
  
  # Net benefits plot
  output$netbenefit_plot =renderPlot({
    withProgress(message = 'Loading plot',{
      if(input$netBen_uptake_choice=="base") {
        plot_netbenefit(netbenefit_table_raw1())
      } else {
        plot_netbenefit(netbenefit_table_raw2())
      }
    })
  })

  
# Health distributon tab --------------------------------------------------

  # Health distributon table
  healthdistribution_table_raw1 = reactive({
    table_healthdistribution_raw(netbenefit_table_raw1())
  })
  healthdistribution_table_raw2 = reactive({
    table_healthdistribution_raw(netbenefit_table_raw2())
  })
  
  # Health distribution plot
  output$healthdistribution_plot =renderPlot({
    withProgress(message = 'Loading plot',{
      plot_healthdistribution(healthdistribution_table_raw(),input$distHealth_uptake_choice)
    })
  })

  
# Inequality measures tab -------------------------------------------------
  
  # Inequality measures tables
  inequality_table_raw1 = reactive({
    table_inequality_raw(healthdistribution_table_raw1(),
                         resCEA(),input$ratioHOC)
  })
  inequality_table_raw2 = reactive({
    table_inequality_raw(healthdistribution_table_raw2(),
                         resCEA(),input$ratioHOC)
  })
  
  inequality_table1 = reactive({
    table_inequality(inequality_table_raw1())
  })
  inequality_table2 = reactive({
    table_inequality(inequality_table_raw2())
  })
  
  # Output table
  
  output$inequality_table =renderDataTable({
    withProgress(message = 'Loading data table',{
      table = table_inequality_comb(inequality_table1(),inequality_table2(),input$choiceUptake2)
      datatable(table,style = 'bootstrap',rownames = FALSE,
                options = list(paging=FALSE,searching=FALSE,info=FALSE)) 
    })
  })
  
  # Net benefit inequality table
  inequality_table_nb_raw1 = reactive({
    table_nb_inequality(netbenefit_table_raw1(),recipients_table_raw1())
  })
  inequality_table_nb_raw2 = reactive({
    table_nb_inequality(netbenefit_table_raw2(),recipients_table_raw2())
  })
  
  output$inequality_table_nb =renderDataTable({
    withProgress(message = 'Loading data table',{
      table = table_nb_inequality_comb(inequality_table_nb_raw1(),inequality_table_nb_raw2(),input$choiceUptake2)
      datatable(table,style = 'bootstrap',rownames = FALSE,
                options = list(paging=FALSE,searching=FALSE,info=FALSE))
    })
  })
  
# Atkinson ----------------------------------------------------------------

  atkinson_table_raw = reactive({
    table_atkinson_raw(healthdistribution_table_raw1(),
                       healthdistribution_table_raw2())
  })
  
  output$atkinson_table =renderDataTable({
    withProgress(message = 'Loading data table',{
      table = table_atkinson(atkinson_table_raw(),imp_AtWeights,
                             weightedicer_raw(),input$choiceUptake2)
      datatable(table,style = 'bootstrap',rownames = FALSE,
                options = list(paging=FALSE,searching=FALSE,info=FALSE))
    })
  })
  
  output$atkinson_plot =renderPlot({
    withProgress(message = 'Loading plot',{
      plot_atkinson(atkinson_table_raw(),input$choiceUptake2)
    })
  })
  
# Equity impact plane -----------------------------------------------------
  
  output$equityimpact_plot =renderPlot({
    withProgress(message = 'Loading plot',{
      plot_equity_impact(inequality_table_raw1(),inequality_table_raw2(),
                         atkinson_table_raw(),input$eip_aversion,
                         input$choiceUptake2,input$intName1,
                         input$compName1)
    })
  })
  
  output$icer_equityimpact_plot =renderPlot({
    if(indicatorICER()==1){
      withProgress(message = 'Loading plot',{
      plot_icer_equity_impact(baseICER_raw(),
                              atkinson_table_raw(),input$eip_icer_aversion,
                              input$choiceUptake2,input$intName1,
                              input$compName1,input$eip_threshold)
      
    }) 
    } else { NULL }

  })
  
  # Implicit weight warnings
  implicit_weight = reactive({
    implicit_weight_raw(input$eip_aversion)
    })
  implicit_weight2 = reactive({
    implicit_weight_raw(input$eip_icer_aversion)
  })
  output$implicit_weight_text <- renderText({ 
    if(input$eip_aversion==0) { paste("This parameter value of 0 places equal weight on health gains and 
                                      losses for the worst-off (IMD1) compared with the best-off (IMD5)",sep="") }
    else { paste0("A parameter of ",input$eip_aversion,
                  " gives health gains for the worst-off (IMD1) a ",implicit_weight(),
                  "% additional weight compared with those for best-off (IMD5)")  }
  })
  output$implicit_weight_text2 <- renderText({ 
    if(input$eip_icer_aversion==0) { paste("This parameter value of 0 places equal weight on health gains and 
                                      losses for the worst-off (IMD1) compared with the best-off (IMD5)",sep="") }
    else { paste0("A parameter of ",input$eip_icer_aversion,
                  " gives health gains for the worst-off (IMD1) a ",implicit_weight2(),
                  "% additional weight compared with those for best-off (IMD5)")  }
  })
  
  indicatorICER = reactive({
    indicator_icer(resCEA())
  })
  output$noEIP_text <- renderText({ 
    if(indicatorICER()==1) { paste0("",sep="") }
    else { paste0("This plot is only produced when the incremental QALYs 
    and costs for an intervention are positive.")  }
  })
  
  # Raw ICER warning
  output$raw_icer_text <- renderText({ 
    if(baseICER()=="dominant") {
      paste0("Warning: Interpret the ICER with caution as the intervention dominates the comparator")
    } else if(baseICER()=="dominated") {
      paste0("Warning: Interpret the ICER with caution as the intervention is dominated by the comparator")
    } else {
      paste0("")
    }
  })
  
# Kolm --------------------------------------------------------------------
  kolm_table_raw = reactive({
    table_kolm_raw(healthdistribution_table_raw1(),healthdistribution_table_raw2())
  })
  
  output$kolm_table =renderDataTable({
    withProgress(message = 'Loading data table',{
      table = table_kolm(kolm_table_raw(),imp_KmWeights,input$choiceUptake2)
      datatable(table,style = 'bootstrap',rownames = FALSE,
                options = list(paging=FALSE,searching=FALSE,info=FALSE))
    })
  })
  
  output$kolm_plot =renderPlot({
    withProgress(message = 'Loading plot',{
      plot_kolm(kolm_table_raw(),input$choiceUptake2)
    })
  })
  

# Markdown report ---------------------------------------------------------

  # Create outputs for Markdown report
  ceaResMD <- reactive({
      data.frame(`Incremental QALYs`=input$incQALYs_c1,
                 `Incremental costs`=paste0("Â£",format(input$incCost_c1,big.mark=",")),
                 `Eligible population`=format(input$intPop_c1,big.mark=","))
  })
    
  output$report_download <- downloadHandler(
    filename = "equity_report.html",
    content = function(file) {
      # Copy the report file to a temporary directory before processing it, in
      # case we don't have write permissions to the current working dir (which
      # can happen when deployed).
      tempReport <- file.path(tempdir(), "summary_report.Rmd")
      file.copy("summary_report.Rmd", tempReport, overwrite = TRUE)
      
      # Set up parameters to pass to Rmd document
      report_params <- list(intName1 = input$intName1,
                            ceaResTable = ceaResMD,
                            rawICER = baseICER_raw,
                            indICER = indicatorICER,
                            ineqAv = input$eip_aversion,
                            ineqAv2 = input$eip_icer_aversion,
                            eipCET = input$eip_threshold,
                            impWeight = implicit_weight,
                            impWeight2 = implicit_weight2,
                            ceaRes = resCEA,
                            ratioHOC = input$ratioHOC,
                            ratioType = input$ratioType,
                            inputTab = input_summary_table,
                            uptakeScen = input$choiceUptake2,
                            recTab1 = recipients_table_raw1,
                            recTab2 = recipients_table_raw2,
                            nbUpChoice = input$netBen_uptake_choice,
                            nbTab1 = netbenefit_table_raw1,
                            nbTab2 = netbenefit_table_raw2,
                            weightedICER = weightedicer_raw,
                            hdistTab1 = healthdistribution_table_raw1,
                            hdistTab2 = healthdistribution_table_raw2,
                            ineqTabRaw1 = inequality_table_raw1,
                            ineqTabRaw2 = inequality_table_raw2,
                            ineqTab1 = inequality_table1,
                            ineqTab2 = inequality_table2,
                            ineqNBTab1 = inequality_table_nb_raw1,
                            ineqNBTab2 = inequality_table_nb_raw2,
                            atTab = atkinson_table_raw,
                            kmTab = kolm_table_raw,
                            nComp = input$nComparator,
                            compName = input$compName1,
                            indName = input$indicationName,
                            codeICD = input$intICD,
                            codeRF = input$intRF,
                            codeType = input$intervention_type,
                            impWeightsAt = imp_AtWeights
                            )
      
      # Knit the document, passing in the `params` list, and eval it in a
      # child of the global environment (this isolates the code in the document
      # from the code in this app).
      rmarkdown::render(tempReport,output_file = file,
                        params=report_params,
                        envir = new.env(parent = globalenv())
      )
    }
  )
})